CREATE TABLE IF NOT EXISTS states (
	id SERIAL PRIMARY KEY,
	name VARCHAR(255) UNIQUE NOT NULL
);


CREATE TABLE IF NOT EXISTS roles (
	id SERIAL PRIMARY KEY,
	name VARCHAR(255) UNIQUE NOT NULL
);


CREATE TABLE IF NOT EXISTS tables (
	id SERIAL PRIMARY KEY,
	name VARCHAR(255) UNIQUE NOT NULL 
);


CREATE TABLE IF NOT EXISTS recipient_types (
	id SERIAL PRIMARY KEY,
	name VARCHAR(255) UNIQUE NOT NULL
);


CREATE TABLE IF NOT EXISTS recipients (
	id SERIAL PRIMARY KEY,
	email VARCHAR(255) NOT NULL UNIQUE,
	type_id INTEGER NOT NULL REFERENCES recipient_types(id),
	status_id INTEGER NOT NULL REFERENCES states(id),
	updated TIMESTAMP WITH TIME ZONE DEFAULT now()
);


CREATE TABLE IF NOT EXISTS recipient_lists (
	id SERIAL PRIMARY KEY,
	author_id INTEGER NOT NULL,
	status_id INTEGER NOT NULL REFERENCES states(id),
	created TIMESTAMP WITH TIME ZONE
);


CREATE TABLE IF NOT EXISTS recipient_in_lists (
	recipient_id INTEGER NOT NULL REFERENCES recipients(id),
	list_id INTEGER NOT NULL REFERENCES recipient_lists(id)
);


CREATE TABLE IF NOT EXISTS tags (
	id SERIAL PRIMARY KEY,
	tag VARCHAR(255) UNIQUE NOT NULL
);


CREATE TABLE IF NOT EXISTS recipient_tags (
	recipient_id INTEGER NOT NULL REFERENCES recipients(id),
	tag_id INTEGER NOT NULL REFERENCES tags(id)
);


CREATE TABLE IF NOT EXISTS organizations (
	id INTEGER PRIMARY KEY REFERENCES recipients(id),
	info JSONB NOT NULL,
	author_id INTEGER NOT NULL,
	created TIMESTAMP WITH TIME ZONE DEFAULT now()
);


CREATE TABLE IF NOT EXISTS org_links (
	org_id INTEGER NOT NULL REFERENCES organizations(id),
	chief_org_id INTEGER NOT NULL REFERENCES organizations(id),
	distance INTEGER NOT NULL DEFAULT 1
);


CREATE TABLE IF NOT EXISTS users (
	id INTEGER PRIMARY KEY REFERENCES recipients(id),
	org_id INTEGER NOT NULL REFERENCES organizations(id),
	info JSONB NOT NULL,
	role_id INTEGER NOT NULL REFERENCES roles(id),
	hash VARCHAR(255),
	author_id INTEGER NOT NULL,
	created TIMESTAMP WITH TIME ZONE DEFAULT now()
);


CREATE TABLE IF NOT EXISTS user_tokens (
	user_id INTEGER UNIQUE NOT NULL REFERENCES users(id) ON DELETE CASCADE,
	token VARCHAR(255) UNIQUE NOT NULL
);


CREATE TABLE user_sessions (
	sid varchar NOT NULL COLLATE "default",
	sess JSONB NOT NULL,
	expire TIMESTAMP(6) NOT NULL
) WITH (OIDS=FALSE);


CREATE TABLE IF NOT EXISTS forms (
	id SERIAL PRIMARY KEY,
	scheme JSONB NOT NULL,
	options JSONB,
	author_id INTEGER NOT NULL REFERENCES users(id),
	status_id INTEGER NOT NULL REFERENCES states(id),
	modified TIMESTAMP WITH TIME ZONE
);


CREATE TABLE IF NOT EXISTS responses (
	id SERIAL PRIMARY KEY,
	form_id INTEGER NOT NULL REFERENCES forms(id),
	list JSONB NOT NULL,
	author_id INTEGER NOT NULL REFERENCES users(id),
	recipient_id INTEGER NOT NULL REFERENCES recipients(id),
	status_id INTEGER NOT NULL,
	modified TIMESTAMP WITH TIME ZONE
);


CREATE TABLE IF NOT EXISTS recipient_lists_tags (
	list_id INTEGER NOT NULL REFERENCES recipient_lists(id),
	tag_id INTEGER NOT NULL REFERENCES tags(id)
);


CREATE TABLE IF NOT EXISTS form_recipient_lists (
	form_id INTEGER NOT NULL REFERENCES forms(id),
	list_id INTEGER NOT NULL REFERENCES recipient_lists(id),
	rights INTEGER NOT NULL
);


CREATE TABLE IF NOT EXISTS status_log (
	table_id INTEGER NOT NULL REFERENCES tables(id),
	object_id INTEGER NOT NULL,
	info JSONB NOT NULL,
	author_id INTEGER NOT NULL REFERENCES users(id),
	timestamp TIMESTAMP WITH TIME ZONE DEFAULT now()
);


ALTER TABLE recipient_lists ADD CONSTRAINT recipient_lists
FOREIGN KEY (author_id) REFERENCES users(id);


ALTER TABLE organizations ADD CONSTRAINT organizations_fk1
FOREIGN KEY (author_id) REFERENCES users(id);


ALTER TABLE users ADD CONSTRAINT users_fk0 
FOREIGN KEY (author_id) REFERENCES users(id);


CREATE OR REPLACE FUNCTION org_links_insert_link_to_itself() RETURNS TRIGGER AS $$
	BEGIN
		INSERT INTO org_links (org_id, chief_org_id, distance) 
			VALUES (NEW.id, NEW.id, 0);
		RETURN NULL;
	END
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION org_links_insert_links() RETURNS TRIGGER AS $$
	DECLARE
		row RECORD;
	BEGIN
		RAISE NOTICE 'NEW: % | % | %', NEW.org_id, NEW.chief_org_id, NEW.distance;
		IF (NEW.distance = 1) THEN
			RAISE NOTICE 'NEW with distance = 1: % | % | %', NEW.org_id, NEW.chief_org_id, NEW.distance;
			FOR row IN
				SELECT down.org_id, up.chief_org_id, 
					down.distance + up.distance + 1 AS distance
				FROM org_links up, org_links down
				WHERE up.org_id = NEW.chief_org_id
					AND down.chief_org_id = NEW.org_id
					AND down.distance + up.distance > 0
			LOOP
				INSERT INTO org_links VALUES(row.org_id, row.chief_org_id, row.distance);
				RAISE NOTICE 'new row: % | % | %', row.org_id, row.chief_org_id, row.distance;
			END LOOP;
		END IF;
		RETURN NULL;
	END
$$ LANGUAGE plpgsql;


CREATE OR REPLACE FUNCTION org_links_delete_orgs_subtree() RETURNS TRIGGER AS $org_links_bd$
	DECLARE 
		row RECORD;
	BEGIN
		RAISE NOTICE 'OLD: % | % | %', OLD.org_id, OLD.chief_org_id, OLD.distance;
		IF (OLD.distance = 1) THEN 
			RAISE NOTICE 'OLD filtered: % | % | %', OLD.org_id, OLD.chief_org_id, OLD.distance;
			FOR row IN 
				SELECT down.org_id, up.chief_org_id, down.distance + up.distance AS distance
				FROM org_links down
					JOIN org_links up
					ON up.org_id = OLD.org_id
						AND down.chief_org_id = OLD.org_id
						AND up.distance > 0
						AND up.distance + down.distance > 1
			LOOP
				RAISE NOTICE 'deleted row: % | % | %', row.org_id, row.chief_org_id, row.distance;
				DELETE FROM org_links 
				WHERE org_id = row.org_id AND chief_org_id = row.chief_org_id;
			END LOOP;
		END IF;
		RETURN NULL;
	END
$org_links_bd$ LANGUAGE plpgsql;


CREATE TRIGGER organizations_ai
	AFTER INSERT ON organizations
	FOR EACH ROW
	EXECUTE PROCEDURE org_links_insert_link_to_itself();


CREATE TRIGGER org_links_ai
	AFTER INSERT ON org_links
	FOR EACH ROW
	EXECUTE PROCEDURE org_links_insert_links();


CREATE TRIGGER org_links_ad
	AFTER DELETE ON org_links
	FOR EACH ROW
	EXECUTE PROCEDURE org_links_delete_orgs_subtree();