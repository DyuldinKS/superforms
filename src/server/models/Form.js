import moment from 'moment';
import db from '../db/index';
import AbstractModel from './AbstractModel';
import {
	isNumber,
	isNatural,
	isString,
	isObject,
	isArray,
	isDate,
} from '../utils/extras';
import { HTTPError } from '../errors';


class Form extends AbstractModel {
	/*----------------------------------------------------------------------------
	------------------------------- STATIC METHODS -------------------------------
	----------------------------------------------------------------------------*/

	static findById(id) {
		return db.query('SELECT * FROM to_form_full(get_form($1)) form;', [id])
			.then(found => (found ? new Form(found) : null));
	}


	static checkTitle(title) {
		return isString(title) && title.length > 0;
	}


	static checkScheme(scheme) {
		if(!isObject(scheme)) return false;

		const { items, order } = scheme;
		if(!isObject(items) || !isArray(order)) return false;

		const ids = Object.keys(items);
		return ids.length === order.length
			&& order.every(id => isObject(items[id]));
	}


	static checkCollecting(c) {
		// here is stub before implementing Collecting class
		return isObject(c);
	}


	static getAnswerValidator(type) {
		const uCased = type && type[0].toUpperCase() + type.slice(1);
		const vName = Form[`is${uCased}AnswerValid`];
		return Form[vName] || Form.textAnswerValid;
	}


	static isTextAnswerValid(question, answer) {
		return isString(answer) && answer.trim().length > 0
			&& answer.length < 2000;
	}


	static isNumberAnswerValid(question, answer) {
		return isNumber(answer)
			&& (!question.integer || Number.isInteger(answer));
	}


	static isSelectAnswerValid(question, answer) {
		if(!isObject(answer)) return false;

		// selected options stored as { [i]: true, [j]: true, ... }
		// where i, j - option indexes in question.options array.
		const selected = question.options
			.map((opt, i) => (i in answer) && opt)
			.filter(opt => opt);

		if('other' in answer) {
			if(!question.optionOther) return false;
			selected.push(answer.other);
		}

		if(selected.some(opt => (!(isString(opt) && opt.length > 0)))) return false;
		return question.multiple
			? selected.length > 0
			: selected.length === 1;
	}


	static isDateAnswerValid(question, answer) {
		const time = moment(answer, 'YYYY-MM-DD');
		return time.isValid();
	}


	static isTimeAnswerValid(question, answer) {
		const time = moment(answer, 'hh:mm:ss');
		return time.isValid();
	}


	static checkAnswers(answers) {
		if(isObject(answers)) {
			throw new HTTPError(400, 'Invalid response.items structure');
		}

		const { items, order } = this.scheme;
		let question;
		let validator;
		order.filter(id => items[id] !== 'input')
			.forEach((id, i) => {
				question = items[id];

				if(question.required && id in answers === false) {
					throw new HTTPError(400, `Missing answer to question #${i}`);
				}

				if(id in answers) {
					validator = Form.getAnswerValidator(question.type);
					if(!validator(question, answers[id])) {
						throw new HTTPError(400, `Invalid answer to ${question.type} question #${i}`)
					}
				}
			});
	}


	/*----------------------------------------------------------------------------
	------------------------------ INSTANCE METHODS ------------------------------
	----------------------------------------------------------------------------*/

	// @implements
	save({ author }) {
		this.ownerId = author.id;

		return super.save({ author });
	}


	// get responses in short(default) or full form
	getResponses(mode) {
		const cast = `to_response_${mode === 'full' ? 'full' : 'short'}`;
		return db.queryAll(
			`SELECT resp_short.* FROM get_responses_by_form($1) resp,
				${cast}(resp) resp_short;`,
			[this.id],
		)
			.then((responses) => {
				this.responses = responses;
				return responses;
			});
	}
}


/*------------------------------------------------------------------------------
----------------------------- PROTOTYPE PROPERTIES -----------------------------
------------------------------------------------------------------------------*/

Form.prototype.tableName = 'forms';

Form.prototype.entityName = 'form';

Form.prototype.props = {
	// values received from client
	title: { writable: true, readable: true, check: Form.checkTitle },
	description: { writable: true, readable: true, check: isString },
	scheme: { writable: true, readable: true, check: Form.checkScheme },

	// values set by model
	collecting: { writable: true, readable: true, check: Form.checkCollecting },
	ownerId: { writable: true, readable: true, check: isNatural },
	authorId: { writable: false, readable: true, check: isNatural },

	// values generated by db
	id: { writable: false, readable: true, check: isNatural },
	created: { writable: false, readable: true, check: isDate },
	updated: { writable: false, readable: true, check: isDate },
	deleted: { writable: false, readable: true, check: isDate },
	questionCount: { writable: false, readable: true },
	responseCount: { writable: false, readable: true },
};

Object.freeze(Form);


export default Form;
